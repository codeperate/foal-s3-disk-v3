"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateMultipartFormDataBody = void 0;
// std
const path_1 = require("path");
// 3p
const core_1 = require("@foal/core");
const Busboy = require("busboy");
// FoalTS
const disk_service_1 = require("./disk.service");
const file_1 = require("./file");
async function convertRejectedPromise(fn, errCallback) {
    try {
        await fn();
    }
    catch (error) {
        errCallback();
        return { error };
    }
    return {};
}
function ValidateMultipartFormDataBody(schema, options = {}) {
    function hook(ctx, services) {
        return new Promise((resolve, reject) => {
            const fields = {};
            const files = {};
            for (const name in schema.files) {
                files[name] = schema.files[name].multiple ? [] : null;
            }
            const disk = services.get(disk_service_1.Disk);
            const fileSizeLimit = core_1.Config.get('settings.multipartRequests.fileSizeLimit', 'number');
            const fileNumberLimit = core_1.Config.get('settings.multipartRequests.fileNumberLimit', 'number');
            let busboy;
            try {
                busboy = new Busboy({
                    headers: ctx.request.headers,
                    limits: {
                        fileSize: fileSizeLimit,
                        files: fileNumberLimit
                    }
                });
            }
            catch (error) {
                return resolve(new core_1.HttpResponseBadRequest({
                    headers: {
                        error: 'INVALID_MULTIPART_FORM_DATA_REQUEST',
                        message: error.message
                    }
                }));
            }
            let sizeLimitReached = false;
            let numberLimitReached = false;
            let latestFileHasBeenUploaded = Promise.resolve({});
            busboy.on('field', (name, value) => fields[name] = value);
            // tslint:disable-next-line: max-line-length
            busboy.on('file', (name, stream, filename, encoding, mimeType) => {
                latestFileHasBeenUploaded = convertRejectedPromise(async () => {
                    stream.on('limit', () => sizeLimitReached = name);
                    if (!(schema.files.hasOwnProperty(name))) {
                        // Ignore unexpected files
                        stream.on('data', () => { });
                        // TODO: Test the line below.
                        // Ignore errors of unexpected files.
                        stream.on('error', () => { });
                        return;
                    }
                    const options = schema.files[name];
                    const extension = path_1.extname(filename).replace('.', '');
                    let path;
                    let buffer;
                    if (options.saveTo) {
                        path = (await disk.write(options.saveTo, stream, { extension })).path;
                    }
                    else {
                        buffer = await core_1.streamToBuffer(stream);
                    }
                    const file = new file_1.File({
                        buffer,
                        encoding,
                        filename,
                        mimeType,
                        path,
                    });
                    if (options.multiple) {
                        files[name].push(file);
                        return;
                    }
                    files[name] = file;
                }, () => stream.resume());
            });
            busboy.on('filesLimit', () => numberLimitReached = true);
            busboy.on('finish', () => resolve(validate()));
            async function deleteUploadedFiles() {
                for (const name in files) {
                    if (!schema.files[name].saveTo) {
                        continue;
                    }
                    if (Array.isArray(files[name])) {
                        await Promise.all(files[name].map(({ path }) => disk.delete(path)));
                        continue;
                    }
                    if (files[name] !== null) {
                        await disk.delete(files[name].path);
                    }
                }
            }
            async function validate() {
                // Wait for all saves to finish.
                // When busboy "finish" event is emitted, it means all busboy streams have ended.
                // It does not mean that other Disk streams/promises have ended/been resolved.
                const { error } = await latestFileHasBeenUploaded;
                // We can only rely upon resolved promises to detect errors in the "finish" handlers.
                // Otherwise, we would attach a "catch" handler _after_ the promise may have been rejected.
                // The code below is an example of this problem:
                //    const promise = Promise.reject("error");
                //    setTimeout(() => {
                //      promise.catch(() => console.log("The promise is caught"));
                //    }, 1000)
                if (error) {
                    throw error;
                }
                if (sizeLimitReached) {
                    await deleteUploadedFiles();
                    return new core_1.HttpResponseBadRequest({
                        body: {
                            error: 'FILE_SIZE_LIMIT_REACHED',
                            message: `The file "${sizeLimitReached}" is too large. The maximum file size is ${fileSizeLimit} bytes.`
                        }
                    });
                }
                if (numberLimitReached) {
                    await deleteUploadedFiles();
                    return new core_1.HttpResponseBadRequest({
                        body: {
                            error: 'FILE_NUMBER_LIMIT_REACHED',
                            message: `Too many files updated. The maximum number of files allowed is ${fileNumberLimit}.`
                        }
                    });
                }
                // Validate the fields
                const ajv = core_1.getAjvInstance();
                const ajvSchema = {
                    additionalProperties: false,
                    properties: schema.fields,
                    required: Object.keys(schema.fields || {}),
                    type: 'object',
                };
                if (schema.fields && !ajv.validate(ajvSchema, fields)) {
                    await deleteUploadedFiles();
                    return new core_1.HttpResponseBadRequest({ body: ajv.errors });
                }
                // Validate the files
                for (const name in schema.files) {
                    if ((files[name] === null || files[name].length === 0) && schema.files[name].required) {
                        await deleteUploadedFiles();
                        return new core_1.HttpResponseBadRequest({
                            body: {
                                error: 'MISSING_FILE',
                                message: `The file "${name}" is required.`
                            }
                        });
                    }
                }
                ctx.request.body = { fields, files };
            }
            ctx.request.pipe(busboy);
            // TODO: Test the reject here
            busboy.on('error', reject);
        });
    }
    const required = schema.fields ? Object.keys(schema.fields) : [];
    const properties = Object.assign({}, schema.fields);
    for (const key in schema.files) {
        const file = schema.files[key];
        if (file.required) {
            required.push(key);
        }
        if (file.multiple) {
            properties[key] = {
                items: {
                    format: 'binary',
                    type: 'string',
                },
                type: 'array',
            };
        }
        else {
            properties[key] = {
                format: 'binary',
                type: 'string',
            };
        }
    }
    const requestBody = {
        content: {
            'multipart/form-data': {
                schema: {
                    properties,
                    required,
                    type: 'object',
                }
            }
        }
    };
    const openapi = [
        core_1.ApiRequestBody(requestBody)
    ];
    return core_1.Hook(hook, openapi, options);
}
exports.ValidateMultipartFormDataBody = ValidateMultipartFormDataBody;
