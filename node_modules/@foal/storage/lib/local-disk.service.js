"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcreteDisk = exports.LocalDisk = void 0;
// std
const fs_1 = require("fs");
const path_1 = require("path");
const stream_1 = require("stream");
const util_1 = require("util");
// 3p
const core_1 = require("@foal/core");
// FoalTS
const disk_service_1 = require("./disk.service");
/**
 * File storage to write, read and delete files in the local file system.
 *
 * @export
 * @class LocalDisk
 * @extends {Disk}
 */
class LocalDisk extends disk_service_1.Disk {
    async write(dirname, content, options = {}) {
        let name = this.hasName(options) ? options.name : await core_1.generateToken();
        if (this.hasExtension(options)) {
            name = `${name}.${options.extension}`;
        }
        const path = path_1.join(dirname, name);
        if (content instanceof Buffer) {
            await util_1.promisify(fs_1.writeFile)(this.getPath(path), content);
        }
        else {
            await new Promise((resolve, reject) => {
                stream_1.pipeline(content, fs_1.createWriteStream(this.getPath(path)), err => {
                    // Note: error streams are unlikely to occur (most "createWriteStream" errors are simply thrown).
                    // TODO: test the error case.
                    if (err) {
                        return reject(err);
                    }
                    resolve();
                });
            });
        }
        return { path };
    }
    async read(path, content) {
        try {
            const { size } = await util_1.promisify(fs_1.stat)(this.getPath(path));
            if (content === 'buffer') {
                return {
                    file: await util_1.promisify(fs_1.readFile)(this.getPath(path)),
                    size
                };
            }
            return {
                file: fs_1.createReadStream(this.getPath(path))
                    // Do not kill the process (and crash the server) if the stream emits an error.
                    // Note: users can still add other listeners to the stream to "catch" the error.
                    // Note: error streams are unlikely to occur (most "createWriteStream" errors are simply thrown).
                    // TODO: test this line.
                    .on('error', () => { }),
                size
            };
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                throw new disk_service_1.FileDoesNotExist(path);
            }
            // TODO: test this line.
            throw error;
        }
    }
    async readSize(path) {
        try {
            const { size } = await util_1.promisify(fs_1.stat)(this.getPath(path));
            return size;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                throw new disk_service_1.FileDoesNotExist(path);
            }
            // TODO: test this line.
            throw error;
        }
    }
    async delete(path) {
        try {
            await util_1.promisify(fs_1.unlink)(this.getPath(path));
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                throw new disk_service_1.FileDoesNotExist(path);
            }
            // TODO: test this line.
            throw error;
        }
    }
    getPath(path) {
        const directory = core_1.Config.getOrThrow('settings.disk.local.directory', 'string', 'You must provide a directory name when using local file storage (LocalDisk).');
        return path_1.join(directory, path);
    }
}
exports.LocalDisk = LocalDisk;
exports.ConcreteDisk = LocalDisk;
